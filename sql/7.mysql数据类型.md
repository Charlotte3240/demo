# 字符类型
## 注意 5.0 以上 varchar(10) 10 代表是长度，5.0一下是字节

| 字符类型   | 大小            | 用途               |
| ---------- | --------------- | ------------------ |
| char       | 0-255字符       | 固定长度字符串     |
| varchar    | 0-65535         | 变长字符串         |
| tinyblob   | 0-255           | 微小的二进制字符串 |
| tinytext   | 0-255           | 短文本字符串       |
| blob       | 0-65535         | 二进制文本数据     |
| text       | 0-65535         | 文本数据           |
| mediumblob | 0-16 777 215    | 中长二进制文本数据 |
| mediumtext | 0-16 777 215    | 中长文本字符串     |
| longblob   | 0-4 294 967 295 | 长二进制文本数据   |
| longtext   | 0-4 294 967 295 | 长文本字符串       |



## 校对规则

```sql
show collation
bin 区分大小写，默认不区分大小写
对排序和对比有影响
```

## left right mid

```sql
-- 把一个字段从左边取两个长度,右边取两个长度
SELECT LEFT (shopName,2) , RIGHT (brandName,2) FROM goods g  

-- 从中间任意位置取 mid(字段,开始位置,长度) 这里开始位置是以1开始的
-- mid(shopName,2)如果长度没有值，则为全部
select MID(shopName,1,1) from goods g  
```

## concat substring char_length

```sql
-- 把shopName字段的数据 后面追加一个‘路由器’字符串
UPDATE goods set shopName = concat(mid(shopName,1),'路由器') where id >0

-- 子字符串 substring(字段,开始位置)
SELECT SUBSTRING(shopName,4) from goods g  
-- 查询字符串长度
select CHAR_LENGTH(shopName) from goods g2  

-- 链接一些字符串查询
select CONCAT('编号:',id) as id , CONCAT('商品名称:',shopName) as sName from goods g   

-- 如果查询的长度超过了4个字符，用省略号
select if (CHAR_LENGTH(shopName) > 4,CONCAT(LEFT (shopName,4),'...'),shopName) from goods g 
```

## upper lower

```sql
select LOWER (shopName) as sName, UPPER (brandName) as bName from goods
```





## 正则和like 筛选

```sql
-- 正则表达式 商品名称中包含ax或者ac的
SELECT * FROM test t  WHERE shopName regexp 'ax|ac'
-- _表示 占位1个字符 第二个字符是x的数据
SELECT * FROM test t  WHERE shopName  LIKE '_x%'

-- REPLACE 函数
update goods set shopName = REPLACE (shopName,'路由器','') where shopName regexp 'ax|ac' 
```



# 数值类型

| 数值类型     | 占用空间(字节) | 范围                   |
| ------------ | -------------- | ---------------------- |
| tinyint(m)   | 1              | -128～127              |
| smallint(m)  | 2              | -32768~32767           |
| mediumint(m) | 3              | -8388608~8388607       |
| int(m)       | 4              | -2147483648~2147483647 |
| bigint(m)    | 8              | + - 9.22*10^18         |

* 取值范围可以加上 unsigned 最大值翻倍
* m表示显示长度 在字段设置为`zerofill`时有效 (⚠️已经被废弃了)



```sql
-- 增加tinyint 字段
ALTER TABLE goods add status tinyint
-- 增加tinyint unsigned 字段
alter table goods add stat tinyint unsigned
```



```sql
-- 增加显示长度为5的一个 int 类型字段
-- mysql 8.0+  已经没有什么卵用了
ALTER  TABLE  goods  add stat int(5) zerofill
```



## 浮点数

| 类型    | 占用空间(字节)                     | 取值范围(有符号)                                             | 取值范围（无符号）                                           |
| ------- | ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| float   | 4                                  | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  |
| double  | 8                                  | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) |
| decimal | DECIMAL(M,D) ，m<65 是总个数，d<30 | 依赖于 M 和 D 的值                                           | 依赖于 M 和 D 的值                                           |

* float 一般7位以下没有精度问题
* double 精度在15-16位
* decimal 精度更高

```sql
-- 增加浮点型数据字段
alter table goods add price float 
-- float 只能显示123456.0
update goods set price = 123456.123456 WHERE id = 7

-- 删除price字段
alter table goods drop price 

-- double 只能显示123456789.12345679
alter table goods  add  price double 
update goods set price = 123456789.123456789 WHERE id = 7

-- decimal 可以正常显示
ALTER TABLE goods add price decimal(20,10)
update goods set price = 123456789.123456789 WHERE id = 6
```



# 枚举类型

```sql
-- 枚举类型

ALTER  TABLE  goods add saleState enum('在售','停售','下架','上架') default '上架'

SELECT brandName , shopName , IF (saleState = 1, '还在卖','现在买不了') as state from goods WHERE price > 50

```



# 集合类型

* 一个set类型最多可以存放64个数据

```sql
-- SET类型 多选 最多添加64个数值
ALTER  TABLE  goods  add tags set ('Wi-Fi6','路由器','巴拉巴拉')
ALTER  TABLE  goods  modify tags set ('Wi-Fi6','路由器','巴拉巴拉','扫雷')
INSERT into goods (brandName,shopName,price,tags) values ('asus','ax11000','9999','Wi-Fi6,路由器,扫雷')

-- find in set 
select * from goods g  WHERE FIND_IN_SET('扫雷',tags) 

SELECT  * from goods g  WHERE tags  LIKE '%路由器%'
-- 这样查询需要全部符合，包括顺序
SELECT * FROM goods g WHERE tags = 'Wi-Fi6,路由器,巴拉巴拉'

-- 模糊匹配set
Wi-Fi6		1*2^0 1
路由器			1*2^1 2
巴拉巴拉  	1*2^2 4
扫雷		  	1*2^3 8

&  值的和
SELECT * FROM  goods g WHERE tags & 8
```

