## explain

| id           | select_type                                                  | table    | partitions | type                                                         | possible_keys                    | key            | key_len    | ref                              | rows               | filtered                                                     | Extra       |
| ------------ | ------------------------------------------------------------ | -------- | ---------- | ------------------------------------------------------------ | -------------------------------- | -------------- | ---------- | -------------------------------- | ------------------ | ------------------------------------------------------------ | ----------- |
| 1            | SIMPLE                                                       | stu      | null       | All                                                          | null                             | null           | null       | null                             | 498316             | 10                                                           | Using where |
| 索引执行顺序 | 查询类型：<br />simple: 基本查询<br />union result: union的结果 | 操作的表 | 分区       | all:全表遍历<br />index:与 all 类似只是扫描所有表，而非数据表<br /><br />range:索引区间获得，如使用 IN(1,2,3)筛选<br />ref:前面表中的非唯一数据<br />eq_ref:前面表中非唯一数据，使用了唯一索引字段，如表关联时使用主键<br />const: 前面表匹配唯一行检索速度快，如果使用主键值比较<br /> | 可能用到的索引，不一定被真正使用 | 最终使用的索引 | 索引字节数 | 列与索引的比较，const 为常量比较 | 预计读出的记录条数 | 通过查询条件获取的最终记录行数占通过type字段指明的搜索方式搜索出来的记录行数的百分比。 | 查询说明    |

## type

> ALL, index, range, ref, eq_ref, const, system, NULL(从左到右，性能从差到好)
>
> const、system、NULL指查询优化到常量级别, 甚至不需要查找时间.

## extra

> useing index>using where > using temporary | using filesort



## 索引类型

| 索引                 | 说明                             |
| -------------------- | -------------------------------- |
| unique 唯一索引      | 不可以出现相同的值，但可以为null |
| index 普通索引       | 允许出现相同索引内容             |
| primary key 主键索引 | 不允许出现相同的值，且不能为null |

```sql
CREATE TABLE `stu` (
  `id` int NOT NULL AUTO_INCREMENT,
  `sname` char(10) DEFAULT NULL,
  `class_id` int(11) DEFAULT NULL,
  `birthday` datetime DEFAULT NULL,
  `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `sex` enum('男','女') DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='学生表';

DELIMITER $$
CREATE PROCEDURE add_stus(IN num int)
BEGIN
DECLARE i int DEFAULT 0;
DECLARE _birthday datetime;
WHILE num>i DO
    SET _birthday  = date_sub(now(),INTERVAL floor(RAND()*1000) day);
    INSERT INTO stu SET
    sname = concat(left(md5(RAND()),5),'charlotte'),
    class_id =1+FLOOR( RAND()*100000),
    birthday = _birthday ,
    sex = 1+FLOOR(RAND()*2 );

    SET i= i+1;
END WHILE;
END
$$
DELIMITER ;

-- 添加50w条记录
call add_stus(500000)

-- type为all
explain select * from stu where birthday = '1992-05-30 11:05:26';
-- type为index
explain select * from stu order by id ;
-- type为range
explain select * from stu where id in(1,2,3);
-- type为const
explain select * from stu where id = 3;
-- type为all 和 eq_ref
explain select * from stu s inner join class c on s.class_id = c.id where sname = '后盾人'


# 索引命名
-- 唯一索引 UN_cloumn
-- 普通索引 IX_cloumn

# 添加索引
ALTER TABLE stu  add index ix_sname(sname)

# 删除索引
alter table stu drop index ix_sname

# 删除主键索引,先去掉auto_increment
alter table stu modify id int
alter table stu drop primary key

# 查看表索引
show index from stu

# 添加索引后查询很快


explain select * from stu WHERE class_id = 5 LIMIT  1
alter table stu add index ix_class_id(class_id)
explain select * from stu WHERE class_id = 5 LIMIT  1

# 使用连接操作多个表，如果没有索引 性能很差
EXPLAIN select * from a 
join b on a.id = b.id 
join c on b.id = c.id

# 前缀索引
ALTER table article add index ix_title(title(30))

# 组合索引
alter table stu add index ix_class_id_status(class_id,status)

-- class_id 有索引 使用ix_class_id这个索引
explain select * from stu WHERE class_id = 3
-- 单独使用status 没有使用索引
explain select * from stu WHERE status  = 3
-- 使用组合索引 ix_class_id_status
EXPLAIN select * from stu WHERE class_id = 3 and status = 3


# 查询优化
-- extra 为 impossiable where
EXPLAIN  SELECT * from stu WHERE FALSE 

-- 没有使用索引，因为索引列进行列计算
EXPLAIN  select * from stu WHERE status+1 = 1
-- 也没有使用索引，进行了left函数计算
EXPLAIN select * from stu WHERE LEFT(sname,1) = 'xxx'

-- like 模糊匹配也不能使用索引
EXPLAIN select * from stu WHERE sname like '%charlotte%'
-- 不是两个% 非模糊匹配 ，使用了索引
EXPLAIN select * from stu WHERE sname like 'charlotte%'

-- 正则也不能使用索引
EXPLAIN select * from stu WHERE sname REGEXP '^charlotte'

-- 相同类型进行比较时会使用索引
EXPLAIN select * from stu WHERE sname = "dasd"
-- 不同类型进行比较不会使用索引
EXPLAIN select * from stu WHERE sname  = 1


# 排序中尽量使用添加索引的列进行排序
EXPLAIN select id from stu order by birthday 
EXPLAIN select id from stu order by id 


# 慢查询
-- 开启慢查询可以获取哪条sql造成的相应过慢进行分析，会带来cpu损耗和日志记录的io开销
-- 可以间歇打开和关闭来进行排查


# 查看慢查询状态
show variables like 'slow_query%'

# 查看慢查询记录的阈值
show variables like 'long_query_time'
# 设置慢查询记录阈值
set session long_query_time = 10


# 开启慢查询
set GLOBAL slow_query_log ='ON'
# 关闭慢查询
set GLOBAL slow_query_log = "OFF"

show variables like 'slow_query%'


# 全局配置
-- 修改mysql 配置文件 my.cnf
-- slow_query_log = ON 
-- slow_query_log_file = ~/slow.log # 修改日志记录位置
-- long_query_time = 1

-- 修改后 重启mysql
-- service mysqld restart
```

