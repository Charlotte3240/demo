```sql
# 锁机制
begin 
	# 是索引，会引起行锁
	UPDATE customer set name = 'charlotte' WHERE id = 1
	# name 没有设置索引，会引起表锁
	UPDATE customer set name = 'momo_sad' WHERE name = 'c8'
commit

# 查询范围对锁的影响
alter TABLE  test add price float 
alter table test add stock int
update test set stock = 1 WHERE id = 1

alter table test add version int default 0


BEGIN 
	-- 在id 1～9 中间的行 都被锁了
	-- 所以这个范围越精确 锁的行越少，即性能越好
	update test set price = 100 WHERE id > 1 and id <9
commit 


# 悲观锁 for UPDATE 
begin
SELECT * from test where id =1 for update
update test set stock = 0 WHERE id = 1 
commit 

# 乐观锁
begin
	select * from test t 
	-- 通过其他字段的条件来 进一步约束 更新的行数据
	-- 其他用户在update的时候 不能得到version = 0的条件，所以影响的行数为0
	-- 注意在使用的时候注意影响的行数判断
	update test set stock = stock -100, version = version -1 WHERE id = 1 and version = 0 
COMMIT 

# 读写锁表
-- 锁定这个表只能读
lock table goods read;
unlock tables 

-- 当前会话可以修改，查询，其他会话无法进行操作
lock table goods write;
SELECT * from goods g 
update goods  set price = 700 where id = 1;
unlock tables
```

