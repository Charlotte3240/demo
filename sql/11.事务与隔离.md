## 并发带来的问题

| 脏读       | 事务A读取事务B的数据，B回滚，A读了错误数据。                 |
| ---------- | ------------------------------------------------------------ |
| 不可重复读 | 事务A多次读取同一数据，B在事务A多次读取的过程中，对数据进行更新，导致A多次读取同一数据时，结果不一致。 |
| 幻读       | 事务A在读取时，B插入了一条新的数据，导致A没有对这条数据进行操作。<br />比如A在进行排序，已经排了一部分，B插入了一个名次靠前的。导致A排序有问题。 |

> * 不可重复读，可以锁行解决，侧重对数据进行更新。
>
> * 幻读需要锁表才能解决，侧重新增或者删除数据。



| 隔离级别                      | 脏读 | 不可重复读 | 幻读 | 说明                                                         |
| ----------------------------- | ---- | ---------- | ---- | ------------------------------------------------------------ |
| 读未提交<br />read-uncommited | ✅    | ✅          | ✅    | 最低隔离级别，一个事务还没提交时的变更，可以被其他事务看到   |
| 不可重复读<br />read-commited | ❌    | ✅          | ✅    | 保证一个事务提交之后才能被另外一个事务读取，另外一个事务不能读取未提交的数据 |
| 可重复读<br />repeatable-read | ❌    | ❌          | ✅    | 多次读取同一范围的数据会返回第一次查询的快照，即使其他事务对该数据做了更新修改，事务在执行期间看到的数据必须是一致的。 |
| 串行化<br />serializable      | ❌    | ❌          | ❌    | 事务100%隔离，避免了脏读、不可重复读、幻读的发生。花费最高。 |

```sql
# 事务与隔离
-- 事务由多条sql组成
-- 失败后 整个事务回滚

show engines
# 修改sql 引擎
ALTER table goods engine = 'InnoDB'

select * FROM goods g 


# 在dbeaver中不能一起执行，要一行一行的执行
#begin  # 或者 start transaction
start transaction
INSERT into goods (brandName,shopName,price) values ('tplink','ac1200', 50)
INSERT into article (title) values ('摸鱼大法')
rollback
commit

# 设置 不自动提交, commit 之后才提交
set autocommit = 0
INSERT into goods (brandName,shopName,price) values ('tplink','ac1200', 50)
commit


# 并发多事务操作一张表

# 查询当前隔离级别
select @@global.transaction_isolation,@@transaction_isolation;


# 设置session隔离级别 为读未提交
set SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED 
# 设置全局隔离级别 为读未提交
set GLOBAL TRANSACTION ISOLATION LEVEL READ  UNCOMMITTED 




```

